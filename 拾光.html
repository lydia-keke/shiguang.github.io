<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>拾光 - 跨越时间的陪伴</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#9D65C9',
            secondary: '#F8F0E3',
            accent: '#FFB6C1',
            neutral: '#FDFAF6',
            dark: '#5A4B60'
          },
          fontFamily: {
            sans: ['Nunito', 'system-ui', 'sans-serif'],
            serif: ['Merriweather', 'Georgia', 'serif']
          },
          boxShadow: {
            'soft': '0 5px 15px rgba(0, 0, 0, 0.05)',
            'warm': '0 8px 30px rgba(157, 101, 201, 0.15)'
          }
        }
      }
    }
  </script>
  <style type="text/tailwindcss">
    @layer utilities {
      .content-auto {
        content-visibility: auto;
      }
      .text-shadow {
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      .bg-gradient-warm {
        background: linear-gradient(135deg, #FDFAF6 0%, #F8F0E3 100%);
      }
      .transition-gentle {
        transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
      }
      .memory-float {
        animation: float 3s ease-in-out infinite;
      }
      @keyframes float {
        0% { transform: translateY(0px); }
        50% { transform: translateY(-10px); }
        100% { transform: translateY(0px); }
      }
      .letter-appear {
        animation: appear 0.05s forwards;
        opacity: 0;
      }
      @keyframes appear {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
      }
      .typing-indicator {
        display: inline-flex;
        align-items: center;
        gap: 2px;
      }
      .typing-indicator span {
        width: 6px;
        height: 6px;
        background-color: #5A4B60;
        border-radius: 50%;
        animation: typing 1.4s infinite ease-in-out both;
      }
      .typing-indicator span:nth-child(1) { animation-delay: -0.32s; }
      .typing-indicator span:nth-child(2) { animation-delay: -0.16s; }
      @keyframes typing {
        0% { transform: translateY(0px); }
        28% { transform: translateY(-5px); }
        44% { transform: translateY(0px); }
      }
      @keyframes letterFly {
        0% {
          transform: translate(-50%, -50%) scale(0) rotate(0deg);
          opacity: 1;
        }
        20% {
          transform: translate(-50%, -50%) scale(1.1) rotate(5deg);
          opacity: 1;
        }
        40% {
          transform: translate(-50%, -50%) scale(1) rotate(0deg);
          opacity: 1;
        }
        60% {
          transform: translate(calc(-50% + 150px), calc(-50% - 200px)) scale(0.9) rotate(10deg);
          opacity: 0.9;
        }
        80% {
          transform: translate(calc(-50% + 300px), calc(-50% - 400px)) scale(0.6) rotate(20deg);
          opacity: 0.6;
        }
        100% {
          transform: translate(calc(-50% + 500px), calc(-50% - 700px)) scale(0.2) rotate(30deg);
          opacity: 0;
        }
      }
      .letter-fly {
        animation: letterFly 2.5s ease-out forwards;
      }
      @keyframes modalShow {
        from {
          transform: scale(0.95);
          opacity: 0;
        }
        to {
          transform: scale(1);
          opacity: 1;
        }
      }
      .modal-show {
        animation: modalShow 0.3s ease-out forwards;
      }
    }
  </style>
</head>
<body class="bg-gradient-warm min-h-screen font-sans text-dark">
  <!-- 顶部导航 -->
  <header class="sticky top-0 z-50 bg-white/80 backdrop-blur-md shadow-soft">
    <div class="container mx-auto px-4 py-3 flex justify-between items-center">
      <div class="flex items-center space-x-2">
        <div class="w-10 h-10 rounded-full bg-gradient-to-r from-primary to-accent flex items-center justify-center">
          <i class="fa fa-heart-o text-white text-xl"></i>
        </div>
        <h1 class="text-xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-primary to-dark">拾光</h1>
      </div>
      <div class="hidden md:flex items-center space-x-6">
        <a href="#home" class="hover:text-primary transition-gentle">首页</a>
        <a href="#features" class="hover:text-primary transition-gentle">功能</a>
        <a href="#about" class="hover:text-primary transition-gentle">关于</a>
      </div>
      <button class="md:hidden text-dark hover:text-primary">
        <i class="fa fa-bars text-xl"></i>
      </button>
    </div>
  </header>

  <!-- 主内容区 -->
  <main class="container mx-auto px-4 py-8 md:py-16">
    <!-- 介绍区域 -->
    <section id="home" class="text-center mb-12 md:mb-20 max-w-3xl mx-auto">
      <h2 class="text-[clamp(1.8rem,5vw,3rem)] font-bold mb-6 leading-tight text-shadow">
    用时光的力量，<br class="md:hidden">陪伴你的每一步成长
  </h2>
  <p class="text-lg md:text-xl text-gray-600 mb-8">
    捕捉日常情绪，记录生活点滴，让过去的你成为未来的光
  </p>
  <div class="flex justify-center space-x-4">
    <button id="start-demo" class="px-6 py-3 bg-primary hover:bg-primary/90 text-white rounded-full shadow-warm transition-gentle flex items-center">
      <i class="fa fa-play-circle mr-2"></i> 开始体验
    </button>
    <button id="learn-more-btn" class="px-6 py-3 bg-white hover:bg-gray-50 text-dark rounded-full shadow-soft transition-gentle">
      了解更多
    </button>
  </div>
</section>

    <!-- 时间轴控制器 -->
    <div class="relative max-w-3xl mx-auto mb-12">
      <div class="absolute top-1/2 left-0 right-0 h-1 bg-gray-200 -translate-y-1/2 z-0"></div>
      <div class="flex justify-between relative z-10">
        <button id="time-1" class="time-btn active w-10 h-10 rounded-full bg-primary text-white flex items-center justify-center shadow-warm transition-gentle">
          <i class="fa fa-comment"></i>
        </button>
        <button id="time-2" class="time-btn w-10 h-10 rounded-full bg-white text-gray-400 flex items-center justify-center shadow-soft transition-gentle">
          <i class="fa fa-refresh"></i>
        </button>
        <button id="time-3" class="time-btn w-10 h-10 rounded-full bg-white text-gray-400 flex items-center justify-center shadow-soft transition-gentle">
          <i class="fa fa-envelope"></i>
        </button>
      </div>
      <div class="flex justify-between mt-2 text-sm text-center text-gray-500">
        <div>即时陪伴</div>
        <div>次日回访</div>
        <div>时光书信</div>
      </div>
    </div>

    <!-- 演示区域 -->
    <section class="max-w-4xl mx-auto">
      <!-- 场景1: 即时对话 -->
      <div id="scene-1" class="scene active">
        <div class="bg-white rounded-2xl shadow-warm overflow-hidden">
          <!-- 聊天窗口头部 -->
          <div class="bg-primary/10 px-6 py-4 border-b border-primary/20 flex items-center">
            <div class="w-10 h-10 rounded-full bg-gradient-to-r from-primary to-accent flex items-center justify-center mr-3">
              <i class="fa fa-comments text-white"></i>
            </div>
            <div>
              <h3 class="font-bold">拾光</h3>
              <p class="text-sm text-gray-500">正在倾听你的心声...</p>
            </div>
          </div>
          
          <!-- 聊天内容区 -->
          <div class="p-6 h-[500px] overflow-y-auto chat-container" id="chat-container-1">
            <!-- 智能体开场白 -->
            <div class="flex mb-6 animate-fade-in">
              <div class="w-8 h-8 rounded-full bg-primary/20 flex items-center justify-center mr-3 mt-1 flex-shrink-0">
                <i class="fa fa-robot text-primary"></i>
              </div>
              <div class="bg-primary/10 rounded-t-xl rounded-br-xl rounded-bl-xl px-4 py-3 max-w-[80%]">
                <p>嗨，最近过得怎么样？想和我分享今天发生的事情吗？</p>
              </div>
            </div>
          </div>
          
          <!-- 聊天输入区 -->
          <div class="px-6 py-4 border-t border-gray-100">
            <div class="flex items-center">
              <input type="text" id="user-input-1" placeholder="输入你的想法..." class="flex-1 px-4 py-3 rounded-full bg-gray-100 focus:outline-none focus:ring-2 focus:ring-primary/50">
              <button id="send-btn-1" class="ml-3 w-10 h-10 rounded-full bg-primary text-white flex items-center justify-center hover:bg-primary/90 transition-gentle">
                <i class="fa fa-paper-plane"></i>
              </button>
            </div>
          </div>
        </div>
      </div>
      
      <!-- 场景2: 次日回访 -->
      <div id="scene-2" class="scene hidden">
        <div class="bg-white rounded-2xl shadow-warm overflow-hidden">
          <!-- 聊天窗口头部 -->
          <div class="bg-primary/10 px-6 py-4 border-b border-primary/20 flex items-center">
            <div class="w-10 h-10 rounded-full bg-gradient-to-r from-primary to-accent flex items-center justify-center mr-3">
              <i class="fa fa-comments text-white"></i>
            </div>
            <div>
              <h3 class="font-bold">拾光</h3>
              <p class="text-sm text-gray-500">次日回访 · 一起看看进展吧</p>
            </div>
          </div>
          
          <!-- 聊天内容区 -->
          <div class="p-6 h-[500px] overflow-y-auto chat-container" id="chat-container-2">
            <!-- 历史消息摘要 -->
            <div class="bg-gray-50 rounded-lg p-3 text-sm text-center text-gray-500 mb-6">
              <i class="fa fa-history mr-1"></i> 昨天的对话
            </div>
            
            <!-- 历史消息容器 -->
            <div id="history-messages">
              <!-- 历史消息将在这里动态生成 -->
            </div>
          </div>
          
          <!-- 聊天输入区 -->
          <div class="px-6 py-4 border-t border-gray-100">
            <div class="flex items-center">
              <input type="text" id="user-input-2" placeholder="分享你的想法..." class="flex-1 px-4 py-3 rounded-full bg-gray-100 focus:outline-none focus:ring-2 focus:ring-primary/50">
              <button id="send-btn-2" class="ml-3 w-10 h-10 rounded-full bg-primary text-white flex items-center justify-center hover:bg-primary/90 transition-gentle">
                <i class="fa fa-paper-plane"></i>
              </button>
            </div>
          </div>
        </div>
      </div>
      
      <!-- 场景3: 时光书信 -->
      <div id="scene-3" class="scene hidden">
        <div class="bg-white rounded-2xl shadow-warm overflow-hidden">
          <!-- 书信头部 -->
          <div class="bg-primary/10 px-6 py-4 border-b border-primary/20 text-center">
            <h3 class="font-bold text-xl" id="letter-title">来自过去的信</h3>
            <p class="text-sm text-gray-500" id="letter-subtitle">5天前的你，想对你说...</p>
          </div>
          
          <!-- 书信内容区 -->
          <div class="p-8 md:p-12 relative">
            <!-- 信纸背景纹理 -->
            <div class="absolute inset-0 bg-[url('https://picsum.photos/id/106/1000/1000')] opacity-5 bg-repeat"></div>
            
            <!-- 信封打开动画容器 -->
            <div class="envelope-container relative z-10">
              <div class="envelope bg-secondary rounded-lg overflow-hidden transform transition-gentle duration-1000 scale-y-0 origin-top">
                <div class="letter p-6 md:p-10 bg-white rounded-md min-h-[500px] shadow-inner">
                  <div class="letter-content space-y-6 opacity-0" id="letter-content">
                    <p class="text-lg">亲爱的keke，现在的你还好吗？</p>
                    
                    <p>5天前的晚上，你因为改方案被否定，躲在办公室里觉得自己"好没用"——其实那天的你，已经连续熬了3个小时改稿，这份坚持本身就很了不起呀。</p>
                    
                    <p>后来你主动找领导沟通，发现问题出在需求理解上，还总结出"先确认需求再动手"的小技巧——你看，挫败里藏着成长呢。</p>
                    
                    <p>现在的你可能还在改方案，但请相信，每一次调整都是在靠近更棒的自己。接下来的日子，遇到难题时，记得回头看看：你一直都在带着经验往前走呀。</p>
                    
                    <p class="mt-10">永远陪着你的，<br>5天前的keke</p>
                  </div>
                </div>
              </div>
              
              <!-- 记忆碎片 -->
              <div class="memory-fragments absolute -right-4 top-1/4 hidden md:block">
                <div id="memory-fragment-event" class="memory-float bg-white rounded-lg shadow-warm p-3 w-40 mb-4 transform rotate-3">
                  <p class="text-sm"><span class="text-primary font-medium">事件：</span>加班改方案被否定</p>
                </div>
                <div id="memory-fragment-emotion" class="memory-float bg-white rounded-lg shadow-warm p-3 w-40 mb-4 transform -rotate-2" style="animation-delay: 0.5s">
                  <p class="text-sm"><span class="text-primary font-medium">情绪：</span>挫败 → 缓解</p>
                </div>
                <div id="memory-fragment-growth" class="memory-float bg-white rounded-lg shadow-warm p-3 w-40 transform rotate-1" style="animation-delay: 1s">
                  <p class="text-sm"><span class="text-primary font-medium">成长：</span>主动沟通的重要性</p>
                </div>
              </div>
            </div>
          </div>
          
          <!-- 互动区 -->
          <div class="px-6 py-6 border-t border-gray-100 bg-gray-50">
            <!-- 生成个性化信件按钮 -->
            <div class="text-center mb-6">
              <button id="generate-letter-btn" class="px-6 py-3 bg-accent hover:bg-accent/90 text-white rounded-full shadow-warm transition-gentle mb-4">
                <i class="fa fa-magic mr-2"></i> 生成我的个性化信件
              </button>
              <p class="text-xs text-gray-500">基于你之前的情绪和事件记录生成专属信件</p>
            </div>
            
            <div class="border-t border-gray-200 pt-6 mt-6">
              <h4 class="text-center font-medium mb-4">想对未来的自己说点什么吗？</h4>
              <textarea id="future-message" placeholder="写下对未来的期待..." class="w-full p-4 rounded-lg border border-gray-200 focus:outline-none focus:ring-2 focus:ring-primary/50 h-24"></textarea>
              <div class="text-center mt-4">
                <button id="send-future" class="px-6 py-3 bg-primary hover:bg-primary/90 text-white rounded-full shadow-warm transition-gentle">
                  <i class="fa fa-paper-plane mr-2"></i> 寄给未来
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
    
    <!-- 功能亮点 -->
<section id="features" class="mt-20">
  <!-- 功能标题 + 概述说明 -->
  <div class="max-w-3xl mx-auto text-center mb-8">
    <h3 class="text-2xl font-bold mb-3">核心功能一览</h3>
    <p class="text-gray-600">
      「拾光」围绕<strong>当下陪伴 → 次日回访 → 时光书信</strong>三条主线，自动生成记忆卡，
      记录你的心情、事件进展与反思，让情绪不只是一闪而过。
    </p>
  </div>

  <!-- 三大功能卡片 -->
  <div class="grid md:grid-cols-3 gap-8">
    <div class="bg-white p-6 rounded-xl shadow-soft hover:shadow-warm transition-gentle text-center">
      <div class="w-16 h-16 rounded-full bg-primary/10 flex items-center justify-center mx-auto mb-4">
        <i class="fa fa-heart text-primary text-2xl"></i>
      </div>
      <h4 class="text-xl font-bold mb-3">即时陪伴</h4>
      <p class="text-gray-600 text-sm leading-relaxed">
        · 根据你当下输入的一句话，识别大致情绪（如难过 / 挫败 / 焦虑 / 开心 等）<br>
        · 生成一张「记忆卡」，记录这一次事件和情绪标签<br>
        · 同时给出一段温柔回应，先接住情绪，再帮你慢慢说清楚发生了什么
      </p>
    </div>
    
    <div class="bg-white p-6 rounded-xl shadow-soft hover:shadow-warm transition-gentle text-center">
      <div class="w-16 h-16 rounded-full bg-primary/10 flex items-center justify-center mx-auto mb-4">
        <i class="fa fa-calendar-check-o text-primary text-2xl"></i>
      </div>
      <h4 class="text-xl font-bold mb-3">次日回访</h4>
      <p class="text-gray-600 text-sm leading-relaxed">
        · 以「昨天的记忆卡」为线索，追问事件有没有新的进展<br>
        · 帮你看到这段时间自己做过的努力，而不是只盯着失败<br>
        · 自动把「进展」和「反思」写回记忆卡，形成一张完整的成长记录
      </p>
    </div>
    
    <div class="bg-white p-6 rounded-xl shadow-soft hover:shadow-warm transition-gentle text-center">
      <div class="w-16 h-16 rounded-full bg-primary/10 flex items-center justify-center mx-auto mb-4">
        <i class="fa fa-clock-o text-primary text-2xl"></i>
      </div>
      <h4 class="text-xl font-bold mb-3">时光对话</h4>
      <p class="text-gray-600 text-sm leading-relaxed">
        · 时光书信，连接着过去与未来的你<br>
        · 拾光会把曾经的片段化作一封来自「过去的信」，带你回望那时的自己，理解曾经的情绪与选择<br>
        · 也会让“未来的你”写信鼓励现在的自己，让成长在时间的往复中悄然发生
      </p>
    </div>
  </div>
</section>
<!-- 关于 拾光 -->
<section id="about" class="mt-20 max-w-4xl mx-auto bg-white p-6 md:p-10 rounded-2xl shadow-soft">
  <h3 class="text-2xl font-bold mb-4 text-center">关于「拾光」</h3>
  <p class="text-gray-600 text-sm md:text-base mb-6 leading-relaxed">
    「拾光」是一个面向个人成长与情绪整理的轻量级实验项目，希望在<strong>专业心理服务</strong>之外，
    给你一个随时可用的「情绪记录本 + 温柔对话对象」。它不会下结论，也不会替你做决定，只是尽量帮你看见：
    <strong>原来这些时刻，我也在很努力地活着。</strong>
  </p>

  <div class="space-y-4 text-sm md:text-base text-gray-700">
    <div>
      <h4 class="font-semibold mb-1">设计理念</h4>
      <p>
        · 把「一次对话」拉长成「一段时间的故事」，通过记忆卡把事件、情绪、进展和反思串起来；<br>
        · 降低表达门槛——你只需要说一句「今天好难过」这样的自然话语，系统会帮你做结构化整理；<br>
        · 保持温柔不过度干预，更多是陪你一起看清，而不是指挥你应该怎么做；<br>
        · 时光书信会在恰当的时刻，以过去或未来的口吻写信给你，让你在往返的文字里看见自己的成长。
      </p>
    </div>

    <div>
      <h4 class="font-semibold mb-1">适合你的使用场景</h4>
      <p>
        · 工作 / 学业被否定、改方案改到怀疑人生的时候；<br>
        · 和家人、伴侣争吵后，还在反复回想「是不是我哪里做得不好」的时候；<br>
        · 想记录一些重要时刻，留一封信给未来的自己时。
      </p>
    </div>

    <div>
      <h4 class="font-semibold mb-1">隐私与边界说明</h4>
      <p>
        · 当前 Demo 版本的「情绪识别」和「记忆卡」逻辑主要在本地浏览器中运行，结果仅供体验参考；<br>
        · 它<strong>不是心理诊断工具</strong>，也不能替代专业心理咨询或医疗服务；<br>
        · 如果你出现了强烈的自我伤害念头或已经有具体计划，一定要优先联系身边可信任的人或当地紧急求助热线。
      </p>
    </div>
  </div>
</section>



    <!-- 情绪识别调试区（帮助你验证记忆卡逻辑） -->
    <section class="mt-16 max-w-3xl mx-auto bg-white p-6 md:p-8 rounded-2xl shadow-soft">
      <h3 class="text-xl font-bold mb-3 flex items-center">
        <i class="fa fa-wrench text-primary mr-2"></i>
        情绪识别调试区
      </h3>
      <p class="text-sm text-gray-500 mb-4">
        在这里输入一句话，看看前端本地规则会如何给你打上情绪标签（仅在本地计算，不会调用大模型）。
      </p>
      <div class="flex flex-col md:flex-row gap-3">
        <input
          id="emotion-debug-input"
          type="text"
          placeholder="例如：今天我男朋友打我了，真的好难过啊"
          class="flex-1 px-4 py-3 rounded-full bg-gray-100 focus:outline-none focus:ring-2 focus:ring-primary/50"
        >
        <button
          id="emotion-debug-btn"
          class="px-5 py-3 bg-primary hover:bg-primary/90 text-white rounded-full shadow-warm transition-gentle"
        >
          测试情绪标签
        </button>
      </div>
      <div
        id="emotion-debug-result"
        class="mt-4 hidden bg-secondary/60 border border-secondary/80 rounded-xl p-4 text-sm leading-relaxed"
      ></div>
    </section>
  </main>

  <!-- 记忆卡弹窗 -->
  <div class="memory-card-popup fixed right-6 top-1/4 bg-white rounded-xl shadow-warm p-4 w-64 transform translate-x-full transition-gentle z-50">
    <div class="flex justify-between items-start mb-3">
      <h4 class="font-bold text-primary">记忆卡已生成</h4>
      <button class="close-memory text-gray-400 hover:text-gray-600">
        <i class="fa fa-times"></i>
      </button>
    </div>
    <div class="space-y-2 text-sm" id="memory-card-content">
      <!-- 记忆卡内容将动态生成 -->
    </div>
    <p class="mt-3 text-[11px] text-gray-400">
      说明：情绪标签由前端本地规则得出，仅用于体验和调试，不等同于专业心理评估。
    </p>
  </div>

  <!-- 固定记忆卡按钮 -->
  <button
    id="toggle-memory-card"
    class="fixed right-6 bottom-6 bg-primary hover:bg-primary/90 text-white rounded-full shadow-warm px-4 py-2 text-sm flex items-center space-x-1 transition-gentle z-40"
    type="button"
  >
    <i class="fa fa-sticky-note-o"></i>
    <span>记忆卡</span>
  </button>

  <!-- 时间选择弹窗 -->
  <div id="time-select-modal" class="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 hidden flex items-center justify-center">
    <div class="bg-white rounded-2xl shadow-warm p-8 max-w-md w-full mx-4 transform scale-95 opacity-0 transition-all duration-300">
      <h3 class="text-2xl font-bold text-center mb-6 text-primary">选择送达时间</h3>
      <p class="text-center text-gray-600 mb-6">这封信将在什么时候送达未来的你？</p>
      
      <div class="space-y-4">
        <!-- 具体时间选项 -->
        <div class="time-option border-2 border-gray-200 rounded-xl p-4 cursor-pointer hover:border-primary transition-gentle" data-type="specific">
          <div class="flex items-center justify-between">
            <div class="flex items-center">
              <div class="w-12 h-12 rounded-full bg-primary/10 flex items-center justify-center mr-4">
                <i class="fa fa-calendar text-primary text-xl"></i>
              </div>
              <div>
                <h4 class="font-bold text-lg">具体时间</h4>
                <p class="text-sm text-gray-500">选择确切的日期和时间</p>
              </div>
            </div>
            <i class="fa fa-chevron-right text-gray-400"></i>
          </div>
        </div>
        
        <!-- 随机时间选项 -->
        <div class="time-option border-2 border-gray-200 rounded-xl p-4 cursor-pointer hover:border-primary transition-gentle" data-type="random">
          <div class="flex items-center justify-between">
            <div class="flex items-center">
              <div class="w-12 h-12 rounded-full bg-accent/20 flex items-center justify-center mr-4">
                <i class="fa fa-question-circle text-accent text-xl"></i>
              </div>
              <div>
                <h4 class="font-bold text-lg">随机时间</h4>
                <p class="text-sm text-gray-500">让系统为你选择一个惊喜时刻</p>
              </div>
            </div>
            <i class="fa fa-chevron-right text-gray-400"></i>
          </div>
        </div>
      </div>
      
      <button class="close-time-modal mt-6 w-full py-3 text-gray-500 hover:text-gray-700 transition-gentle">
        取消
      </button>
    </div>
  </div>

  <!-- 具体时间选择器 -->
  <div id="specific-time-modal" class="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 hidden flex items-center justify-center">
    <div class="bg-white rounded-2xl shadow-warm p-8 max-w-md w-full mx-4 transform scale-95 opacity-0 transition-all duration-300">
      <h3 class="text-2xl font-bold text-center mb-6 text-primary">选择具体时间</h3>
      
      <div class="space-y-4 mb-6">
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-2">日期</label>
          <input type="date" id="future-date" class="w-full px-4 py-3 rounded-lg border border-gray-200 focus:outline-none focus:ring-2 focus:ring-primary/50" min="">
        </div>
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-2">时间</label>
          <input type="time" id="future-time" class="w-full px-4 py-3 rounded-lg border border-gray-200 focus:outline-none focus:ring-2 focus:ring-primary/50">
        </div>
      </div>
      
      <div class="flex space-x-3">
        <button class="close-specific-time flex-1 py-3 text-gray-500 hover:text-gray-700 transition-gentle rounded-lg border border-gray-200">
          返回
        </button>
        <button id="confirm-specific-time" class="flex-1 py-3 bg-primary hover:bg-primary/90 text-white rounded-lg transition-gentle">
          确认
        </button>
      </div>
    </div>
  </div>

  <!-- 信件传出动画容器 -->
  <div id="letter-fly-animation" class="fixed inset-0 z-50 pointer-events-none hidden">
    <div class="letter-envelope-wrapper absolute top-1/2 left-1/2">
      <div class="letter-envelope bg-white rounded-lg shadow-warm p-6">
        <div class="flex items-center space-x-3">
          <i class="fa fa-envelope text-primary text-3xl"></i>
          <div>
            <p class="font-bold text-lg">信件已寄出</p>
            <p class="text-sm text-gray-500" id="delivery-time-text"></p>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- 页脚 -->
  <footer class="bg-white mt-20 py-10">
    <div class="container mx-auto px-4 text-center">
      <div class="flex items-center justify-center space-x-2 mb-4">
        <div class="w-8 h-8 rounded-full bg-gradient-to-r from-primary to-accent flex items-center justify-center">
          <i class="fa fa-heart-o text-white"></i>
        </div>
        <h2 class="text-lg font-bold bg-clip-text text-transparent bg-gradient-to-r from-primary to-dark">拾光</h2>
      </div>
      <p class="text-gray-500 mb-6">用科技传递温度，让陪伴跨越时间</p>
      <div class="flex justify-center space-x-6 text-gray-400">
        <a href="#" class="hover:text-primary transition-gentle"><i class="fa fa-weibo"></i></a>
        <a href="#" class="hover:text-primary transition-gentle"><i class="fa fa-wechat"></i></a>
        <a href="#" class="hover:text-primary transition-gentle"><i class="fa fa-github"></i></a>
      </div>
      <p class="text-gray-400 text-sm mt-6">© 2025 拾光 - 温暖陪伴每一刻</p>
    </div>
  </footer>

  <script>
    // ================== 1. LLM 配置：硅基流动 ==================
    const SILICONFLOW_CONFIG = {
      baseUrl: "https://api.siliconflow.cn/v1",
      // ⚠️ 建议不要在正式线上页面里直接暴露真实 Key。
      // 开发 / 本地调试时，请手动把下面这一行替换成你自己的 Key：
      // 例如：apiKey: "sk-xxxxxxxxxxxxxxxxxxxx"
      apiKey: "sk-lkeqrbfrjdjlxmrondawafxmiqchlyunoyvknbhxpcjjpvia",
      model: "Qwen/Qwen3-14B"
    };
  
    // ================== 2. 全局用户数据结构 ==================
    const userData = {
      messages: [], // { sender: 'user' | 'agent', text: string, timestamp: Date }
      memoryCard: {
        event: "",
        time: "",
        emotion: "",
        details: "",
        progress: "",
        reflection: "",
        debug: ""
      }
    };
  
    // 情绪关键词库（本地小分析，用来做“AI记忆标签”和 LLM 提示增强）
    const emotionKeywords = {
      // 先把明显负向情绪划得更细一点
      难过: [
        "难过", "好难过", "伤心", "悲伤", "难受",
        "委屈", "心碎", "崩溃", "想哭", "哭",
        "被打", "打我", "被骂"
      ],
      挫败: ["挫败", "没用", "失败", "不行", "失落", "沮丧"],
      焦虑: ["焦虑", "担心", "紧张", "害怕", "担忧", "压力大"],
      愤怒: ["生气", "愤怒", "火大", "不满", "讨厌", "烦躁"],
      // 最后再放开心
      开心: ["开心", "高兴", "快乐", "兴奋", "满意", "愉快", "开心死了"]
    };
  
    // ================== 3. 页面初始化 ==================
    document.addEventListener('DOMContentLoaded', function () {
      initEventListeners();
  
      // 添加淡入动画样式
      const style = document.createElement('style');
      style.textContent = `
        @keyframes fadeIn {
          from { opacity: 0; transform: translateY(10px); }
          to { opacity: 1; transform: translateY(0); }
        }
        .animate-fade-in {
          animation: fadeIn 0.5s ease-out forwards;
        }
      `;
      document.head.appendChild(style);
    });
  
    // ================== 4. 事件绑定（UI、按钮等） ==================
    function initEventListeners() {
      const timeBtns = document.querySelectorAll('.time-btn');
      const scenes = document.querySelectorAll('.scene');
  
      // 时间轴切换
      timeBtns.forEach((btn, index) => {
        btn.addEventListener('click', function () {
          timeBtns.forEach(b => {
            b.classList.remove('active', 'bg-primary', 'text-white');
            b.classList.add('bg-white', 'text-gray-400');
          });
          this.classList.add('active', 'bg-primary', 'text-white');
          this.classList.remove('bg-white', 'text-gray-400');
  
          scenes.forEach(scene => {
            scene.classList.add('hidden');
            scene.classList.remove('active');
          });
  
          const targetScene = document.getElementById(`scene-${index + 1}`);
          targetScene.classList.remove('hidden');
          targetScene.classList.add('active');
  
          // 场景2：加载历史消息
          if (index + 1 === 2) {
            loadHistoryMessages();
          }
  
          // 场景3：信封动画和重置为案例
          if (index + 1 === 3) {
            const letterContent = document.getElementById('letter-content');
            
            // 重置信件内容为案例（如果还没有生成个性化信件）
            if (!letterContent.dataset.isPersonalized) {
              // 重置标题为案例
              document.getElementById('letter-title').textContent = '来自过去的信';
              document.getElementById('letter-subtitle').textContent = '5天前的你，想对你说...';
              
              letterContent.innerHTML = `
                <p class="text-lg">亲爱的keke，现在的你还好吗？</p>
                <p>5天前的晚上，你因为改方案被否定，躲在办公室里觉得自己"好没用"——其实那天的你，已经连续熬了3个小时改稿，这份坚持本身就很了不起呀。</p>
                <p>后来你主动找领导沟通，发现问题出在需求理解上，还总结出"先确认需求再动手"的小技巧——你看，挫败里藏着成长呢。</p>
                <p>现在的你可能还在改方案，但请相信，每一次调整都是在靠近更棒的自己。接下来的日子，遇到难题时，记得回头看看：你一直都在带着经验往前走呀。</p>
                <p class="mt-10">永远陪着你的，<br>5天前的keke</p>
              `;
            } else {
              // 如果已经生成个性化信件，更新记忆碎片
              updateMemoryFragments();
            }
            
            setTimeout(() => {
              document.querySelector('.envelope').classList.remove('scale-y-0');
              setTimeout(() => {
                animateLetter();
              }, 800);
            }, 300);
          }
        });
      });
  
      // 场景1发送消息
      document.getElementById('send-btn-1').addEventListener('click', function () {
        sendMessage(1);
      });
      document.getElementById('user-input-1').addEventListener('keypress', function (e) {
        if (e.key === 'Enter') {
          sendMessage(1);
        }
      });
  
      // 场景2发送消息
      document.getElementById('send-btn-2').addEventListener('click', function () {
        sendMessage(2);
      });
      document.getElementById('user-input-2').addEventListener('keypress', function (e) {
        if (e.key === 'Enter') {
          sendMessage(2);
        }
      });
  
      // 生成个性化信件按钮（场景3）
      document.getElementById('generate-letter-btn').addEventListener('click', function () {
        generatePersonalizedLetter();
      });
  
      // 寄给未来按钮（场景3）
      document.getElementById('send-future').addEventListener('click', function () {
        const message = document.getElementById('future-message').value.trim();
        if (message) {
          showTimeSelectModal();
        } else {
          alert('请输入想对未来的自己说的话');
        }
      });
  
      // ======= 时间选择弹窗逻辑（保持原有） =======
      function showTimeSelectModal() {
        const modal = document.getElementById('time-select-modal');
        const modalContent = modal.querySelector('div');
        modal.classList.remove('hidden');
        setTimeout(() => {
          modalContent.classList.add('modal-show');
        }, 10);
      }
  
      function hideTimeSelectModal() {
        const modal = document.getElementById('time-select-modal');
        const modalContent = modal.querySelector('div');
        modalContent.classList.remove('modal-show');
        setTimeout(() => {
          modal.classList.add('hidden');
        }, 300);
      }
  
      function showSpecificTimeModal() {
        const modal = document.getElementById('specific-time-modal');
        const modalContent = modal.querySelector('div');
        const dateInput = document.getElementById('future-date');
  
        const tomorrow = new Date();
        tomorrow.setDate(tomorrow.getDate() + 1);
        dateInput.min = tomorrow.toISOString().split('T')[0];
  
        hideTimeSelectModal();
        setTimeout(() => {
          modal.classList.remove('hidden');
          setTimeout(() => {
            modalContent.classList.add('modal-show');
          }, 10);
        }, 300);
      }
  
      function hideSpecificTimeModal() {
        const modal = document.getElementById('specific-time-modal');
        const modalContent = modal.querySelector('div');
        modalContent.classList.remove('modal-show');
        setTimeout(() => {
          modal.classList.add('hidden');
        }, 300);
      }
  
      document.querySelectorAll('.time-option').forEach(option => {
        option.addEventListener('click', function () {
          const type = this.getAttribute('data-type');
          if (type === 'specific') {
            showSpecificTimeModal();
          } else if (type === 'random') {
            const randomDays = Math.floor(Math.random() * 30) + 1;
            const randomDate = new Date();
            randomDate.setDate(randomDate.getDate() + randomDays);
            const randomHour = Math.floor(Math.random() * 24);
            const randomMinute = Math.floor(Math.random() * 60);
  
            const deliveryTime = {
              date: randomDate.toLocaleDateString('zh-CN', { year: 'numeric', month: 'long', day: 'numeric' }),
              time: `${String(randomHour).padStart(2, '0')}:${String(randomMinute).padStart(2, '0')}`,
              fullDate: randomDate
            };
  
            hideTimeSelectModal();
            sendLetterToFuture(deliveryTime);
          }
        });
      });
  
      document.getElementById('confirm-specific-time').addEventListener('click', function () {
        const dateInput = document.getElementById('future-date');
        const timeInput = document.getElementById('future-time');
  
        if (!dateInput.value || !timeInput.value) {
          alert('请选择完整的日期和时间');
          return;
        }
  
        const selectedDate = new Date(dateInput.value + 'T' + timeInput.value);
        const now = new Date();
  
        if (selectedDate <= now) {
          alert('请选择未来的时间');
          return;
        }
  
        const deliveryTime = {
          date: selectedDate.toLocaleDateString('zh-CN', { year: 'numeric', month: 'long', day: 'numeric' }),
          time: timeInput.value,
          fullDate: selectedDate
        };
  
        hideSpecificTimeModal();
        sendLetterToFuture(deliveryTime);
      });
  
      document.querySelector('.close-time-modal').addEventListener('click', hideTimeSelectModal);
      document.querySelector('.close-specific-time').addEventListener('click', function () {
        hideSpecificTimeModal();
        setTimeout(() => {
          showTimeSelectModal();
        }, 300);
      });
  
      document.getElementById('time-select-modal').addEventListener('click', function (e) {
        if (e.target === this) hideTimeSelectModal();
      });
      document.getElementById('specific-time-modal').addEventListener('click', function (e) {
        if (e.target === this) hideSpecificTimeModal();
      });
  
      function sendLetterToFuture(deliveryTime) {
        const message = document.getElementById('future-message').value.trim();
        if (!message) return;
  
        const animationContainer = document.getElementById('letter-fly-animation');
        const envelopeWrapper = animationContainer.querySelector('.letter-envelope-wrapper');
        const deliveryTimeText = document.getElementById('delivery-time-text');
  
        deliveryTimeText.textContent = `将在 ${deliveryTime.date} ${deliveryTime.time} 送达`;
  
        animationContainer.classList.remove('hidden');
        envelopeWrapper.classList.remove('letter-fly');
        envelopeWrapper.style.transform = 'translate(-50%, -50%) scale(0)';
  
        setTimeout(() => {
          envelopeWrapper.classList.add('letter-fly');
        }, 100);
  
        setTimeout(() => {
          animationContainer.classList.add('hidden');
          envelopeWrapper.classList.remove('letter-fly');
          envelopeWrapper.style.transform = '';
          document.getElementById('future-message').value = '';
  
          setTimeout(() => {
            alert(`信件已成功寄出！\n将在 ${deliveryTime.date} ${deliveryTime.time} 送达未来的你。`);
          }, 500);
        }, 2600);
      }
  
      // 关闭记忆卡
      document.querySelector('.close-memory').addEventListener('click', function () {
        document.querySelector('.memory-card-popup').style.transform = 'translateX(120%)';
      });
  
      // “开始体验”按钮：自动打一条示例消息
      document.getElementById('start-demo').addEventListener('click', function () {
        const input = document.getElementById('user-input-1');
        input.value = '今天加班改了3版方案，还是被领导说没抓住重点，感觉自己好没用，特别挫败。';
        sendMessage(1);
      });

      // 记忆卡手动打开 / 收起按钮
      const toggleMemoryBtn = document.getElementById('toggle-memory-card');
      if (toggleMemoryBtn) {
        toggleMemoryBtn.addEventListener('click', function () {
          const popup = document.querySelector('.memory-card-popup');
          if (!popup) return;
          const current = popup.style.transform;
          if (current === 'translateX(0px)' || current === 'translateX(0)' ) {
            popup.style.transform = 'translateX(120%)';
          } else {
            if (!userData.memoryCard || !userData.memoryCard.event) {
              const content = document.getElementById('memory-card-content');
              content.innerHTML = '<div class="text-sm text-gray-500">目前还没有生成记忆卡，先在上面的对话区说点什么吧。</div>';
              document.querySelector('.memory-card-popup h4').textContent = '记忆卡';
            }
            popup.style.transform = 'translateX(0)';
          }
        });
      }

      // 情绪识别调试区按钮
      const debugBtn = document.getElementById('emotion-debug-btn');
      if (debugBtn) {
        debugBtn.addEventListener('click', function () {
          const input = document.getElementById('emotion-debug-input');
          const resultEl = document.getElementById('emotion-debug-result');
          const text = (input.value || '').trim();
          if (!text) {
            resultEl.classList.remove('hidden');
            resultEl.innerHTML = '<p class="text-sm text-red-500">请输入一句话再测试。</p>';
            return;
          }
          const analysis = analyzeMessage(text, { updateMemory: false });
          const emotionText = analysis.emotion
            ? `${analysis.emotion}（程度：${analysis.intensity}）`
            : '未识别到情绪标签';
          const debugText = analysis.debugReason || '没有匹配到任何关键词，仅作为普通文本记录。';
          resultEl.classList.remove('hidden');
          resultEl.innerHTML = `
            <p class="text-sm"><span class="font-medium text-gray-600">输入文本：</span>${text}</p>
            <p class="text-sm mt-1"><span class="font-medium text-gray-600">识别情绪：</span>${emotionText}</p>
            <p class="text-sm mt-1 text-gray-600"><span class="font-medium">识别说明：</span>${debugText}</p>
            <p class="text-xs mt-2 text-gray-400">说明：这里的结果与记忆卡使用的是同一套本地规则，不会调用大模型，也不会被发送到服务器。</p>
          `;
        });
      }
    }
  
    // ================== 5. 发送消息（场景1/2） ==================
    function sendMessage(sceneNumber) {
      const input = document.getElementById(`user-input-${sceneNumber}`);
      const message = input.value.trim();
      const chatContainer = document.getElementById(`chat-container-${sceneNumber}`);
  
      if (!message) return;
  
      input.value = '';
  
      const userMessageDiv = document.createElement('div');
      userMessageDiv.className = 'flex justify-end mb-6 animate-fade-in';
      userMessageDiv.innerHTML = `
        <div class="bg-secondary rounded-t-xl rounded-bl-xl rounded-br-xl px-4 py-3 max-w-[80%]">
          <p>${message}</p>
        </div>
      `;
      chatContainer.appendChild(userMessageDiv);
  
      userData.messages.push({
        sender: 'user',
        text: message,
        timestamp: new Date()
      });
  
      scrollToBottom(chatContainer);
  
      if (sceneNumber === 1) {
        analyzeMessageAndRespond(message, chatContainer); // 即时陪伴
      } else if (sceneNumber === 2) {
        generateReflectionResponse(message, chatContainer); // 次日回访
      }
    }
  
    // ================== 6. 获取当前日期和时间 ==================
    function getCurrentDateTime() {
      const now = new Date();
      const year = now.getFullYear();
      const month = now.getMonth() + 1;
      const day = now.getDate();
      const hours = now.getHours();
      const minutes = now.getMinutes();
      
      // 格式化时间点
      let timePoint = '';
      if (hours < 6) {
        timePoint = '凌晨';
      } else if (hours < 9) {
        timePoint = '早上';
      } else if (hours < 12) {
        timePoint = '上午';
      } else if (hours < 14) {
        timePoint = '中午';
      } else if (hours < 18) {
        timePoint = '下午';
      } else if (hours < 22) {
        timePoint = '晚上';
      } else {
        timePoint = '深夜';
      }
      
      // 返回格式：2025年1月15日 下午 15:30
      return `${year}年${month}月${day}日 ${timePoint} ${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
    }
  
    // ================== 7. 本地情绪分析 & 记忆卡 ==================
    function analyzeMessage(message, { updateMemory = true, isFirstMessage = false } = {}) {
      let detectedEmotion = '';
      let emotionIntensity = '中等';
      let matchedKeyword = '';
  
      for (const [emotion, keywords] of Object.entries(emotionKeywords)) {
        for (const keyword of keywords) {
          if (message.includes(keyword)) {
            detectedEmotion = emotion;
            matchedKeyword = keyword;
            if (
              message.includes('很') ||
              message.includes('非常') ||
              message.includes('特别') ||
              message.includes('好难过') ||
              message.includes('好生气') ||
              message.includes('好害怕')
            ) {
              emotionIntensity = '较高';
            } else if (message.includes('有点') || message.includes('稍微')) {
              emotionIntensity = '较低';
            }
            break;
          }
        }
        if (detectedEmotion) break;
      }
  
      let eventText = message;
      if (eventText.length > 30) {
        eventText = eventText.substring(0, 30) + '...';
      }
  
      let debugReason = '';
      if (detectedEmotion) {
        debugReason = matchedKeyword
          ? `命中关键词「${matchedKeyword}」，因此标记为「${detectedEmotion}」`
          : `通过本地规则识别为「${detectedEmotion}」`;
      } else {
        debugReason = '没有匹配到本地情绪关键词，已记录事件文本。';
      }
  
      // 判断是否是第一句话（检查记忆卡是否已有事件）
      const isFirst = isFirstMessage || !userData.memoryCard || !userData.memoryCard.event;
      const memoryCardGenerated = isFirst; // 只有第一句话才生成新的记忆卡
  
      // 更新记忆卡（如果 updateMemory 为 true）
      if (updateMemory) {
        if (isFirst) {
          // 第一句话：创建新的记忆卡，识别事件和情绪
          userData.memoryCard = {
            event: eventText,
            time: getCurrentDateTime(),
            emotion: detectedEmotion ? `${detectedEmotion}（程度：${emotionIntensity}）` : '未识别到明确情绪',
            details: message,
            progress: '',
            reflection: '',
            debug: debugReason
          };
        } else {
          // 后续对话：补充细节，追加到details中
          if (userData.memoryCard.details) {
            userData.memoryCard.details += '\n\n' + message;
          } else {
            userData.memoryCard.details = message;
          }
          
          // 如果后续对话中识别到情绪，更新情绪字段
          if (detectedEmotion) {
            userData.memoryCard.emotion = `${detectedEmotion}（程度：${emotionIntensity}）`;
            userData.memoryCard.debug = (userData.memoryCard.debug || '').replace(/ \| 已补充细节/g, '') + ' | 已识别情绪：' + detectedEmotion;
          } else {
            // 更新debug信息，说明这是补充细节
            userData.memoryCard.debug = (userData.memoryCard.debug || '').replace(/ \| 已补充细节/g, '') + ' | 已补充细节';
          }
        }
      }
  
      return {
        emotion: detectedEmotion,
        intensity: emotionIntensity,
        memoryCardGenerated: memoryCardGenerated,
        debugReason,
        isFirst: isFirst
      };
    }
  
    // 以前的规则回复逻辑，作为 LLM 失败时的兜底
    function generateRuleBasedResponse(analysis) {
      if (analysis.emotion === '挫败') {
        return '连续改方案还被否定，肯定会特别委屈吧，付出的努力没被看到，换作是我也会难过的（拍拍）。是哪个部分没达到领导的预期呀？';
      } else if (analysis.emotion === '难过') {
        return '听起来你真的很难过，能和我多说说发生了什么吗？有时候把事情说出来会好受一些。';
      } else if (analysis.emotion === '焦虑') {
        return '我能感受到你的焦虑，这种担心的感觉确实不好受。你在担心什么具体的事情呢？';
      } else if (analysis.emotion === '开心') {
        return '听到你这么开心，我也很高兴！能和我分享一下是什么好事让你这么开心吗？';
      } else if (analysis.emotion === '愤怒') {
        return '能感觉到你现在很生气，一定是发生了让你很不满的事情吧？愿意和我说说吗？';
      } else {
        // 没有识别到情绪时，引导用户表达感受
        return '谢谢你和我分享这些。你现在感觉怎么样？是难过、挫败、焦虑、愤怒，还是开心？或者有其他感受吗？说出来会好受一些的。';
      }
    }
  
    // ================== 8. 构造对话历史给 LLM ==================
    function buildChatHistoryForLLM(maxTurns = 6) {
      const recent = userData.messages.slice(-maxTurns);
      return recent.map(msg => ({
        role: msg.sender === 'user' ? 'user' : 'assistant',
        content: msg.text
      }));
    }
  
    // ================== 9. 调用硅基流动 LLM ==================
    async function callFutureSelfAgent({ scene, message, analysis, isReflection = false }) {
      const historyMessages = buildChatHistoryForLLM();
  
      const systemPrompt = isReflection
        ? "你是“拾光（EchoSelf）”，一个帮助用户做【事件复盘 + 未来自我反思】的 AI 伙伴。你会参考对话和“记忆卡”，用温柔、真诚的语气，帮用户看到自己的努力和成长，再给出一点点轻微的引导。回答不要超过 150 字，分成 2～4 段短句，可以偶尔用“未来的我”视角说话，但不要假装真的预知未来。不要用生硬的鸡汤句式。"
        : "你是“拾光（EchoSelf）”，一个【情绪陪伴 + 未来自我】AI。说话风格：口语化、温柔、不评判，先接住当下情绪，再轻轻引导用户思考“未来的自己会怎么看这件事”。一条回复控制在 80～130 字之间，分 1～3 段短句结尾用一个温柔的问题继续对话。不要使用“你必须/应该”之类强控制表达。";
  
      const userPromptParts = [];
  
      userPromptParts.push(`当前场景：${scene}`);
      if (analysis && analysis.emotion) {
        userPromptParts.push(`本地情绪检测：${analysis.emotion}（强度：${analysis.intensity}）`);
      }
      if (analysis && analysis.debugReason) {
        userPromptParts.push(`情绪检测说明：${analysis.debugReason}`);
      }
      if (isReflection && userData.memoryCard && userData.memoryCard.event) {
        userPromptParts.push(`记忆卡事件：${userData.memoryCard.event}`);
        userPromptParts.push(`当时的详细记录：${userData.memoryCard.details || ""}`);
      }
      userPromptParts.push(`用户刚刚说：${message}`);
  
      if (isReflection) {
        userPromptParts.push("请先肯定用户这段时间做过的努力，再帮他/她从这件事里看到一点点成长，最后用一个温柔的问题邀请 TA 继续说说接下来想怎么做。");
      } else {
        // 如果没有识别到情绪，引导用户表达感受
        if (!analysis || !analysis.emotion) {
          userPromptParts.push("用户没有明确表达情绪。请温柔地询问用户现在的感受，并给出具体的情绪词语选项来引导，例如：难过、挫败、焦虑、愤怒、开心等。格式可以是：'你现在感觉怎么样？是难过、挫败、焦虑，还是其他感受呢？'");
        } else {
          userPromptParts.push("请先共情、再澄清、再轻轻带到「未来的自己」，最后用一个开放式问题结尾。");
        }
      }
  
      const body = {
        model: SILICONFLOW_CONFIG.model,
        messages: [
          { role: "system", content: systemPrompt },
          ...historyMessages,
          { role: "user", content: userPromptParts.join("\n") }
        ],
        temperature: 0.9,
        top_p: 0.9,
        max_tokens: 512,
        stream: false
      };
  
      const resp = await fetch(`${SILICONFLOW_CONFIG.baseUrl}/chat/completions`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${SILICONFLOW_CONFIG.apiKey}`
        },
        body: JSON.stringify(body)
      });
  
      if (!resp.ok) {
        const errText = await resp.text().catch(() => "");
        console.error("SiliconFlow API error:", resp.status, errText);
        throw new Error("LLM 请求失败");
      }
  
      const data = await resp.json();
      const reply =
        data &&
        data.choices &&
        data.choices[0] &&
        data.choices[0].message &&
        data.choices[0].message.content;
  
      return (reply || "刚刚网络有点小卡，我好像没完全听清，可以再和我说一次吗？").trim();
    }
  
    // ================== 10. 场景1：即时陪伴（调用 LLM） ==================
    async function analyzeMessageAndRespond(message, chatContainer) {
      const typingDiv = document.createElement('div');
      typingDiv.className = 'flex mb-6 typing-indicator-container';
      typingDiv.innerHTML = `
        <div class="w-8 h-8 rounded-full bg-primary/20 flex items-center justify-center mr-3 mt-1 flex-shrink-0">
          <i class="fa fa-robot text-primary"></i>
        </div>
        <div class="bg-primary/10 rounded-t-xl rounded-br-xl rounded-bl-xl px-4 py-3 max-w-[80%]">
          <div class="typing-indicator">
            <span></span>
            <span></span>
            <span></span>
          </div>
        </div>
      `;
      chatContainer.appendChild(typingDiv);
      scrollToBottom(chatContainer);
  
      // 判断是否是第一句话（检查记忆卡是否已有事件）
      const isFirstMessage = !userData.memoryCard || !userData.memoryCard.event;
      const analysis = analyzeMessage(message, { updateMemory: true, isFirstMessage: isFirstMessage });
  
      let response;
      try {
        response = await callFutureSelfAgent({
          scene: "即时陪伴",
          message,
          analysis,
          isReflection: false
        });
      } catch (e) {
        console.error(e);
        response = generateRuleBasedResponse(analysis); // 兜底
      }
  
      // 移除"正在输入"
      if (typingDiv.parentNode === chatContainer) {
        chatContainer.removeChild(typingDiv);
      }
  
      const agentMessageDiv = document.createElement('div');
      agentMessageDiv.className = 'flex mb-6 animate-fade-in';
      agentMessageDiv.innerHTML = `
        <div class="w-8 h-8 rounded-full bg-primary/20 flex items-center justify-center mr-3 mt-1 flex-shrink-0">
          <i class="fa fa-robot text-primary"></i>
        </div>
        <div class="bg-primary/10 rounded-t-xl rounded-br-xl rounded-bl-xl px-4 py-3 max-w-[80%]">
          <p>${response.replace(/\n/g, '<br>')}</p>
        </div>
      `;
      chatContainer.appendChild(agentMessageDiv);
  
      userData.messages.push({
        sender: 'agent',
        text: response,
        timestamp: new Date()
      });
  
      scrollToBottom(chatContainer);
  
      // 第一句话：显示记忆卡；后续对话：更新记忆卡但不显示弹窗（或可以选择更新显示）
      if (analysis.memoryCardGenerated && analysis.isFirst) {
        // 第一句话，显示记忆卡
        showMemoryCard();
      } else if (!analysis.isFirst) {
        // 后续对话，更新记忆卡显示（如果记忆卡弹窗已打开）
        updateMemoryCardDisplay();
      }
    }
  
    // ================== 11. 场景2：次日回访（调用 LLM） ==================
    async function generateReflectionResponse(message, chatContainer) {
      const typingDiv = document.createElement('div');
      typingDiv.className = 'flex mb-6 typing-indicator-container';
      typingDiv.innerHTML = `
        <div class="w-8 h-8 rounded-full bg-primary/20 flex items-center justify-center mr-3 mt-1 flex-shrink-0">
          <i class="fa fa-robot text-primary"></i>
        </div>
        <div class="bg-primary/10 rounded-t-xl rounded-br-xl rounded-bl-xl px-4 py-3 max-w-[80%]">
          <div class="typing-indicator">
            <span></span>
            <span></span>
            <span></span>
          </div>
        </div>
      `;
      chatContainer.appendChild(typingDiv);
      scrollToBottom(chatContainer);
  
      // 把“进展”写入记忆卡
      userData.memoryCard.progress = message;
  
      let response;
      try {
        response = await callFutureSelfAgent({
          scene: "次日回访",
          message,
          analysis: null,
          isReflection: true
        });
      } catch (e) {
        console.error(e);
        response = "听完你的这些更新，我能感觉到你是真的在努力面对这件事。你看，哪怕过程不完美，你也没有停在原地。你觉得这段时间，自己最值得被肯定的一点是什么？";
      }
  
      if (typingDiv.parentNode === chatContainer) {
        chatContainer.removeChild(typingDiv);
      }
  
      const agentMessageDiv = document.createElement('div');
      agentMessageDiv.className = 'flex mb-6 animate-fade-in';
      agentMessageDiv.innerHTML = `
        <div class="w-8 h-8 rounded-full bg-primary/20 flex items-center justify-center mr-3 mt-1 flex-shrink-0">
          <i class="fa fa-robot text-primary"></i>
        </div>
        <div class="bg-primary/10 rounded-t-xl rounded-br-xl rounded-bl-xl px-4 py-3 max-w-[80%]">
          <p>${response.replace(/\n/g, '<br>')}</p>
        </div>
      `;
      chatContainer.appendChild(agentMessageDiv);
  
      userData.messages.push({
        sender: 'agent',
        text: response,
        timestamp: new Date()
      });
  
      // 用回复的前几十个字，填充“反思摘要”
      const cleanText = response.replace(/\s+/g, '');
      userData.memoryCard.reflection =
        cleanText.length > 30 ? cleanText.slice(0, 30) + "..." : cleanText;
  
      scrollToBottom(chatContainer);
      updateMemoryCardForReflection();
    }
  
    // ================== 12. 记忆卡展示 & 历史消息 ==================
    function showMemoryCard() {
      const memoryCardContent = document.getElementById('memory-card-content');
      const detailsText = userData.memoryCard.details || '';
      const detailsDisplay = detailsText.length > 50 ? detailsText.substring(0, 50) + '...' : detailsText;
      
      memoryCardContent.innerHTML = `
        <div><span class="text-gray-500">事件：</span>${userData.memoryCard.event}</div>
        <div><span class="text-gray-500">时间：</span>${userData.memoryCard.time}</div>
        <div><span class="text-gray-500">情绪：</span>${userData.memoryCard.emotion}</div>
        <div><span class="text-gray-500">细节：</span>${detailsDisplay}</div>
        ${userData.memoryCard.debug ? `<div class="pt-1 mt-1 border-t border-dashed border-gray-200 text-xs text-gray-500"><span class="font-medium">识别说明：</span>${userData.memoryCard.debug}</div>` : ''}
      `;
      document.querySelector('.memory-card-popup').style.transform = 'translateX(0)';
      document.querySelector('.memory-card-popup h4').textContent = '记忆卡已生成';
    }
  
    // 更新记忆卡显示（用于后续对话补充细节时）
    function updateMemoryCardDisplay() {
      const memoryCardContent = document.getElementById('memory-card-content');
      const popup = document.querySelector('.memory-card-popup');
      
      // 如果记忆卡弹窗已打开，则更新内容
      if (popup && popup.style.transform === 'translateX(0px)' || popup.style.transform === 'translateX(0)') {
        const detailsText = userData.memoryCard.details || '';
        const detailsDisplay = detailsText.length > 50 ? detailsText.substring(0, 50) + '...' : detailsText;
        
        memoryCardContent.innerHTML = `
          <div><span class="text-gray-500">事件：</span>${userData.memoryCard.event}</div>
          <div><span class="text-gray-500">时间：</span>${userData.memoryCard.time}</div>
          <div><span class="text-gray-500">情绪：</span>${userData.memoryCard.emotion}</div>
          <div><span class="text-gray-500">细节：</span>${detailsDisplay}</div>
          ${userData.memoryCard.debug ? `<div class="pt-1 mt-1 border-t border-dashed border-gray-200 text-xs text-gray-500"><span class="font-medium">识别说明：</span>${userData.memoryCard.debug}</div>` : ''}
        `;
        document.querySelector('.memory-card-popup h4').textContent = '记忆卡已更新';
      }
    }
  
    function updateMemoryCardForReflection() {
      const memoryCardContent = document.getElementById('memory-card-content');
      memoryCardContent.innerHTML = `
        <div><span class="text-gray-500">事件：</span>${userData.memoryCard.event}</div>
        <div><span class="text-gray-500">进展：</span>${userData.memoryCard.progress.length > 30 ? userData.memoryCard.progress.substring(0, 30) + '...' : userData.memoryCard.progress}</div>
        <div><span class="text-gray-500">反思：</span>${userData.memoryCard.reflection}</div>
        ${userData.memoryCard.debug ? `<div class="pt-1 mt-1 border-t border-dashed border-gray-200 text-xs text-gray-500"><span class="font-medium">识别说明：</span>${userData.memoryCard.debug}</div>` : ''}
      `;
      document.querySelector('.memory-card-popup h4').textContent = '记忆卡已更新';
      document.querySelector('.memory-card-popup').style.transform = 'translateX(0)';
    }
  
    function loadHistoryMessages() {
      const historyContainer = document.getElementById('history-messages');
  
      if (userData.messages.length === 0) {
        historyContainer.innerHTML = `
          <div class="flex mb-3 opacity-70">
            <div class="w-6 h-6 rounded-full bg-primary/20 flex items-center justify-center mr-2 mt-1 flex-shrink-0">
              <i class="fa fa-robot text-primary text-xs"></i>
            </div>
            <div class="bg-primary/10 rounded-t-xl rounded-br-xl rounded-bl-xl px-3 py-2 text-sm max-w-[80%]">
              <p>嗨，最近过得怎么样？想和我分享今天发生的事情吗？</p>
            </div>
          </div>
          
          <div class="flex justify-end mb-3 opacity-70">
            <div class="bg-secondary rounded-t-xl rounded-bl-xl rounded-br-xl px-3 py-2 text-sm max-w-[80%]">
              <p>今天加班改了3版方案，还是被领导说没抓住重点，感觉自己好没用，特别挫败。</p>
            </div>
          </div>
        `;
  
        setTimeout(() => {
          const chatContainer = document.getElementById('chat-container-2');
          const agentReply = document.createElement('div');
          agentReply.className = 'flex mb-6 animate-fade-in';
          agentReply.innerHTML = `
            <div class="w-8 h-8 rounded-full bg-primary/20 flex items-center justify-center mr-3 mt-1 flex-shrink-0">
              <i class="fa fa-robot text-primary"></i>
            </div>
            <div class="bg-primary/10 rounded-t-xl rounded-br-xl rounded-bl-xl px-4 py-3 max-w-[80%]">
              <p>昨天你说改方案被领导否定，特别挫败，今天有没有和领导再沟通下具体问题呀？现在感觉好点了吗？</p>
            </div>
          `;
          chatContainer.appendChild(agentReply);
          scrollToBottom(chatContainer);
        }, 500);
      } else {
        historyContainer.innerHTML = '';
        userData.messages.forEach(msg => {
          const messageDiv = document.createElement('div');
          if (msg.sender === 'user') {
            messageDiv.className = 'flex justify-end mb-3 opacity-70';
            messageDiv.innerHTML = `
              <div class="bg-secondary rounded-t-xl rounded-bl-xl rounded-br-xl px-3 py-2 text-sm max-w-[80%]">
                <p>${msg.text}</p>
              </div>
            `;
          } else {
            messageDiv.className = 'flex mb-3 opacity-70';
            messageDiv.innerHTML = `
              <div class="w-6 h-6 rounded-full bg-primary/20 flex items-center justify-center mr-2 mt-1 flex-shrink-0">
                <i class="fa fa-robot text-primary text-xs"></i>
              </div>
              <div class="bg-primary/10 rounded-t-xl rounded-br-xl rounded-bl-xl px-3 py-2 text-sm max-w-[80%]">
                <p>${msg.text}</p>
              </div>
            `;
          }
          historyContainer.appendChild(messageDiv);
        });
  
        const chatContainer = document.getElementById('chat-container-2');
        const agentReply = document.createElement('div');
        agentReply.className = 'flex mb-6 animate-fade-in';
        agentReply.innerHTML = `
          <div class="w-8 h-8 rounded-full bg-primary/20 flex items-center justify-center mr-3 mt-1 flex-shrink-0">
            <i class="fa fa-robot text-primary"></i>
          </div>
          <div class="bg-primary/10 rounded-t-xl rounded-br-xl rounded-bl-xl px-4 py-3 max-w-[80%]">
            <p>昨天我们聊到了你遇到的问题，今天有什么新的进展吗？想听听你的情况。</p>
          </div>
        `;
        chatContainer.appendChild(agentReply);
        scrollToBottom(chatContainer);
      }
    }
  
    // ================== 13. 生成个性化信件 ==================
    async function generatePersonalizedLetter() {
      // 检查是否有用户数据
      if (!userData.memoryCard || !userData.memoryCard.event) {
        alert('还没有生成记忆卡，请先在"即时陪伴"或"次日回访"中记录一些内容。');
        return;
      }
  
      const btn = document.getElementById('generate-letter-btn');
      const originalText = btn.innerHTML;
      btn.disabled = true;
      btn.innerHTML = '<i class="fa fa-spinner fa-spin mr-2"></i> 正在生成信件...';
  
      try {
        // 构建提示词
        const systemPrompt = "你是「拾光（EchoSelf）」，一个帮助用户回顾过去、看见成长的AI伙伴。你需要根据用户之前的情绪和事件记录，以「过去的自己」的口吻，写一封温柔、真诚的信给「现在的自己」。信件应该：1) 先肯定当时的努力和坚持；2) 回顾事件的发展和成长；3) 给现在的自己一些鼓励和提醒。字数控制在200-300字，分成3-5段，语气温柔、不评判，像朋友一样。";
  
        const userPrompt = `请根据以下信息生成一封来自过去的信：
  
事件：${userData.memoryCard.event}
情绪：${userData.memoryCard.emotion}
详细记录：${userData.memoryCard.details || ''}
${userData.memoryCard.progress ? `进展：${userData.memoryCard.progress}` : ''}
${userData.memoryCard.reflection ? `反思：${userData.memoryCard.reflection}` : ''}

请以"X天前的你"的口吻（X可以是3-7天，根据事件时间感选择），写一封给现在的自己的信。格式如下：

亲爱的[名字]，现在的你还好吗？

[第一段：回顾当时的事件和情绪，肯定当时的努力]

[第二段：回顾后续的发展和成长]

[第三段：给现在的自己一些鼓励和提醒]

永远陪着你的，
X天前的[名字]

注意：如果用户没有提供名字，可以用"你"代替。`;
  
        const body = {
          model: SILICONFLOW_CONFIG.model,
          messages: [
            { role: "system", content: systemPrompt },
            { role: "user", content: userPrompt }
          ],
          temperature: 0.9,
          top_p: 0.9,
          max_tokens: 800,
          stream: false
        };
  
        const resp = await fetch(`${SILICONFLOW_CONFIG.baseUrl}/chat/completions`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${SILICONFLOW_CONFIG.apiKey}`
          },
          body: JSON.stringify(body)
        });
  
        if (!resp.ok) {
          const errText = await resp.text().catch(() => "");
          console.error("SiliconFlow API error:", resp.status, errText);
          throw new Error("生成信件失败，请稍后重试");
        }
  
        const data = await resp.json();
        const letterText = data?.choices?.[0]?.message?.content || "";
  
        if (!letterText) {
          throw new Error("未能生成信件内容");
        }
  
        // 更新信件内容
        updateLetterContent(letterText);
  
        // 更新标题
        document.getElementById('letter-title').textContent = '来自过去的信（你的专属信件）';
        // 尝试从信件中提取天数
        const dayMatch = letterText.match(/(\d+)天前的/);
        if (dayMatch) {
          document.getElementById('letter-subtitle').textContent = `${dayMatch[1]}天前的你，想对你说...`;
        } else {
          document.getElementById('letter-subtitle').textContent = '过去的你，想对你说...';
        }
  
        // 更新记忆碎片
        updateMemoryFragments();
  
        // 重新播放动画
        setTimeout(() => {
          const letterContent = document.getElementById('letter-content');
          letterContent.style.opacity = '0';
          setTimeout(() => {
            animateLetter();
          }, 300);
        }, 100);
  
      } catch (error) {
        console.error("生成信件错误:", error);
        alert('生成信件时出现错误：' + error.message);
      } finally {
        btn.disabled = false;
        btn.innerHTML = originalText;
      }
    }
  
    // 更新信件内容的函数
    function updateLetterContent(letterText) {
      const letterContent = document.getElementById('letter-content');
      
      // 将文本按段落分割（假设LLM返回的格式是分段落的）
      let paragraphs = letterText.split('\n\n').filter(p => p.trim());
      
      // 如果没有分段，尝试按单行分割
      if (paragraphs.length <= 1) {
        paragraphs = letterText.split('\n').filter(p => p.trim());
      }
  
      // 构建HTML
      let html = '';
      paragraphs.forEach((para, index) => {
        const trimmed = para.trim();
        if (!trimmed) return;
        
        // 检查是否是签名行（包含"永远"、"天前的"等关键词）
        if (trimmed.includes('永远') || trimmed.includes('天前的') || trimmed.includes('陪着你的')) {
          html += `<p class="mt-10">${trimmed.replace(/\n/g, '<br>')}</p>`;
        } else if (index === 0 && trimmed.includes('亲爱的')) {
          // 第一段如果是问候，使用大字体
          html += `<p class="text-lg">${trimmed}</p>`;
        } else {
          html += `<p>${trimmed.replace(/\n/g, '<br>')}</p>`;
        }
      });
  
      letterContent.innerHTML = html;
      // 标记为个性化信件
      letterContent.dataset.isPersonalized = 'true';
    }
  
    // 更新记忆碎片（基于用户记忆卡）
    function updateMemoryFragments() {
      if (!userData.memoryCard) return;
  
      // 更新事件
      const eventFragment = document.getElementById('memory-fragment-event');
      if (eventFragment) {
        const eventText = userData.memoryCard.event || '未记录事件';
        eventFragment.querySelector('p').innerHTML = `<span class="text-primary font-medium">事件：</span>${eventText}`;
      }
  
      // 更新情绪
      const emotionFragment = document.getElementById('memory-fragment-emotion');
      if (emotionFragment) {
        let emotionText = userData.memoryCard.emotion || '未识别到明确情绪';
        // 简化情绪显示，移除程度信息
        emotionText = emotionText.replace(/（程度：[^）]+）/g, '');
        // 如果有进展，显示情绪变化
        if (userData.memoryCard.progress) {
          emotionText += ' → 缓解';
        }
        emotionFragment.querySelector('p').innerHTML = `<span class="text-primary font-medium">情绪：</span>${emotionText}`;
      }
  
      // 更新成长
      const growthFragment = document.getElementById('memory-fragment-growth');
      if (growthFragment) {
        let growthText = '';
        // 优先使用反思内容
        if (userData.memoryCard.reflection) {
          growthText = userData.memoryCard.reflection;
          // 如果反思太长，截取前20个字符
          if (growthText.length > 20) {
            growthText = growthText.substring(0, 20) + '...';
          }
        } else if (userData.memoryCard.progress) {
          // 如果没有反思，使用进展
          growthText = userData.memoryCard.progress;
          if (growthText.length > 20) {
            growthText = growthText.substring(0, 20) + '...';
          }
        } else {
          // 如果都没有，根据情绪生成简单的成长描述
          const emotion = userData.memoryCard.emotion || '';
          if (emotion.includes('挫败')) {
            growthText = '从挫败中学习';
          } else if (emotion.includes('难过')) {
            growthText = '情绪管理能力';
          } else if (emotion.includes('焦虑')) {
            growthText = '应对压力的方法';
          } else if (emotion.includes('愤怒')) {
            growthText = '情绪调节技巧';
          } else {
            growthText = '自我成长';
          }
        }
        growthFragment.querySelector('p').innerHTML = `<span class="text-primary font-medium">成长：</span>${growthText}`;
      }
    }
  
    // ================== 14. 信件动画 & 滚动 ==================
    function animateLetter() {
      const letterContent = document.getElementById('letter-content');
  
      letterContent.style.opacity = '1';
      letterContent.style.transition = 'opacity 0.5s ease-in';
  
      const paragraphs = letterContent.querySelectorAll('p');
      let delay = 0;
  
      paragraphs.forEach((p) => {
        const originalHTML = p.innerHTML;
        const originalText = p.textContent || p.innerText;
  
        p.innerHTML = '';
        p.style.opacity = '1';
  
        setTimeout(() => {
          let charIndex = 0;
          const charInterval = setInterval(() => {
            if (charIndex < originalText.length) {
              p.textContent = originalText.substring(0, charIndex + 1);
              charIndex++;
            } else {
              clearInterval(charInterval);
              if (originalHTML.includes('<br>')) {
                p.innerHTML = originalHTML;
              }
            }
          }, 30);
        }, delay);
  
        delay += originalText.length * 30 + 200;
      });
    }
  
    function scrollToBottom(container) {
      container.scrollTop = container.scrollHeight;
    }
  </script>
</body>
</html>
